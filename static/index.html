<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Govee H5075 Metrics</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js" async></script>
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 20px;
            background-color: #e9ecef;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            position: relative;
            padding-top: 30px;
        }
        .sensor-card {
            background: #ffffff;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            width: 320px;
            transition: transform 0.2s;
        }
        .sensor-card:hover {
            transform: translateY(-5px);
        }
        .sensor-title {
            text-align: center;
            margin: 0 0 15px 0;
            font-size: 1.4em;
            color: #444;
        }
        .gauges-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .gauge-container {
            display: flex;
            align-items: center;
            padding: 10px;
            border-radius: 6px;
            background: #f1f3f5;
        }
        .gauge-wrapper {
            width: 150px;
            height: 150px;
            flex-shrink: 0;
            position: relative;
        }
        .gauge-info {
            width: 80px;
            margin-right: 10px;
            flex-shrink: 0;
        }
        .gauge-label {
            font-size: 1em;
            color: #555;
            margin-bottom: 4px;
        }
        .value-label {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
        }
        .last-updated {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #777;
            font-size: 0.9em;
        }
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: #ccc;
            z-index: 1000;
        }
        
        .progress-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #2196f3, #21cbf3);
            transform-origin: left;
            transition: transform 1s linear;
        }
    </style>
</head>
<body>
    <div class="progress-container" role="progressbar" aria-valuemin="0" aria-valuemax="100">
        <div class="progress-bar" id="updateProgress"></div>
    </div>
    <div class="container" id="sensors-container" role="main">
        <div class="last-updated" id="lastUpdated"></div>
    </div>

    <script>
        const REFRESH_INTERVAL = 30000; // 30 seconds in milliseconds
        let progressBar;
        let updateTimer;

        function startProgressBar() {
            if (progressBar) {
                progressBar.style.transition = 'none';
                progressBar.style.transform = 'scaleX(1)';
                // Force reflow
                progressBar.offsetHeight;
                progressBar.style.transition = 'transform ' + REFRESH_INTERVAL + 'ms linear';
                progressBar.style.transform = 'scaleX(0)';
            }
        }

        function createProgressBar(element, value, maxValue, title, color, unit) {
            console.log(`Creating progress bar: ${title}`);
            console.log(`Value: ${value}, Max Value: ${maxValue}, Color: ${color}, Unit: ${unit}`);

            if (isNaN(value) || isNaN(maxValue) || value < 0 || maxValue <= 0) {
                console.error(`Invalid value or maxValue for progress bar: ${title}`);
                return;
            }

            const wrapper = document.createElement('div');
            wrapper.className = 'gauge-container';

            const infoDiv = document.createElement('div');
            infoDiv.className = 'gauge-info';
            
            const label = document.createElement('div');
            label.className = 'gauge-label';
            label.textContent = title;
            infoDiv.appendChild(label);

            const valueLabel = document.createElement('div');
            valueLabel.className = 'value-label';
            valueLabel.textContent = `${value.toFixed(1)}${unit}`;
            infoDiv.appendChild(valueLabel);

            wrapper.appendChild(infoDiv);

            const progressBarWrapper = document.createElement('div');
            progressBarWrapper.style.width = '100%';
            progressBarWrapper.style.backgroundColor = '#e0e0e0';
            progressBarWrapper.style.borderRadius = '4px';
            progressBarWrapper.style.overflow = 'hidden';
            progressBarWrapper.style.marginTop = '5px';

            const progressBar = document.createElement('div');
            progressBar.style.width = `${(value / maxValue) * 100}%`;
            progressBar.style.height = '20px';
            progressBar.style.transition = 'width 0.5s ease';

            // Apply color based on the battery percentage
            if (title === 'Battery') {
                if (value <= 20) {
                    progressBar.style.backgroundColor = '#ff0000'; // Red
                } else if (value <= 50) {
                    progressBar.style.backgroundColor = '#ffff00'; // Yellow
                } else {
                    progressBar.style.backgroundColor = '#4caf50'; // Green
                }
            } else if (title === 'Temperature') {
                if (value <= 10) {
                    progressBar.style.backgroundColor = '#2196f3'; // Blue
                } else if (value <= 25) {
                    progressBar.style.backgroundColor = '#ff9800'; // Orange
                } else {
                    progressBar.style.backgroundColor = '#f44336'; // Red
                }
            } else {
                progressBar.style.backgroundColor = color; // Default color
            }

            progressBarWrapper.appendChild(progressBar);
            wrapper.appendChild(progressBarWrapper);

            element.appendChild(wrapper);
        }

        function updateMetrics() {
            startProgressBar();
            
            fetch('/metrics')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.text();
                })
                .then(data => {
                    const metrics = {};
                    const lines = data.split('\n');
                    
                    lines.forEach(line => {
                        if (line.startsWith('#')) return;
                        
                        const match = line.match(/^([^{]+){name="([^"]+)"} (.+)$/);
                        if (!match) return;
                        
                        const [, metricName, sensorName, value] = match;
                        if (!metrics[sensorName]) {
                            metrics[sensorName] = {};
                        }
                        metrics[sensorName][metricName.trim()] = parseFloat(value);
                    });

                    const container = document.getElementById('sensors-container');
                    container.innerHTML = '<div class="last-updated" id="lastUpdated"></div>';

                    Object.entries(metrics).forEach(([sensorName, values]) => {
                        const card = document.createElement('div');
                        card.className = 'sensor-card';
                        
                        const title = document.createElement('h2');
                        title.className = 'sensor-title';
                        title.textContent = sensorName;
                        card.appendChild(title);

                        const gaugesDiv = document.createElement('div');
                        gaugesDiv.className = 'gauges-container';
                        card.appendChild(gaugesDiv);

                        if (values['govee_h5075_temperature'] !== undefined) {
                            createProgressBar(gaugesDiv, values['govee_h5075_temperature'], 30, 'Temperature', '#ff4081', 'Â°C');
                        }
                        if (values['govee_h5075_humidity'] !== undefined) {
                            createProgressBar(gaugesDiv, values['govee_h5075_humidity'], 100, 'Humidity', '#2196f3', '%');
                        }
                        if (values['govee_h5075_battery'] !== undefined) {
                            createProgressBar(gaugesDiv, values['govee_h5075_battery'], 100, 'Battery', '#4caf50', '%');
                        }

                        container.appendChild(card);
                    });

                    const lastUpdated = document.getElementById('lastUpdated');
                    lastUpdated.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
                })
                .catch(error => {
                    console.error('Error fetching metrics:', error);
                    const container = document.getElementById('sensors-container');
                    container.innerHTML = '<div role="alert" style="color: red; text-align: center;">Failed to load metrics. Please try again later.</div>';
                });
        }

        // Initialize progress bar and start updates
        document.addEventListener('DOMContentLoaded', () => {
            progressBar = document.getElementById('updateProgress');
            
            // Clear any existing interval
            if (updateTimer) {
                clearInterval(updateTimer);
            }
            
            // Initial update
            updateMetrics();
            
            // Set up periodic updates
            updateTimer = setInterval(updateMetrics, REFRESH_INTERVAL);
        });
    </script>
</body>
</html>